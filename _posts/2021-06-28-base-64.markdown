---
layout: post
title: Base64编码和JPEG数据格式
image: 1.jpg
date: 2021-06-28 16:36:20 +0200
tags: [base64, JPEG]
categories: Common
---
Intro: Base64 encoding & JPEG data format.
前段时间的需求中涉及到图片的Base64数据，因此去做了一些了解。其实它的概念和原理都非常的简单，下面就从这几个方面介绍一下。

***

- Base64是什么
- Base64的编码原理
- 为什么要用Base64


### Base64编码

##### Base64是什么

Base64是一种简单的**编码技术**。它可以将**二进制数据**编码成主要**由64种字符组成的字符串**，其中包括大写字母`A-Z`、小写字母`a-z`、数字`0-9`，加号`+`和斜杠`/`。一个字符也被称为 "Base64单元"。实际上，Base64编码也可能包含换行和`=`，这个我们后面再做说明。

##### Base64的编码原理

为什么有64个字符呢？

不同于有8个bit的字节，在进行Base64编码时，我们把**6个bit**作为一个单元，我们知道`2^6 = 64`，也就是说6bit的范围在0~63，一共64种可能。我们将64个字符一一对应到一个数值上，就是Base64的编码方式了。

![enter image description here](image/base64.jpeg)

那么我们可以看出，每24bit的二进制数据，也就是每3个字节，就可以用4个字符表示。

但是如果数据的字节数不是3的倍数，以至于bit总数不是6的倍数怎么办呢？

首先我们需要用`0`将数据补充至6的倍数。但同时，我们需要做一个标记，告诉解码器在解码时需要删除多余的位数：

- 如果最后一个Base64单位差4bit，补充4个0并且在Base64结果末尾加两个`=`
- 如果最后一个Base64单位差2bit，补充2个0并且在Base64结果末尾加一个`=`

举个简单的例子，把我的企微英文名进行编码：

```
编码前：lyris

二进制数据：0110110001111001011100100110100101110011
```

| 分组 | 011011 | 000111 | 100101 | 110010 | 011010 | 010111 | 0011(00) |
| ---- | ------ | ------ | ------ | ------ | ------ | ------ | -------- |
| 索引 | 27     | 7      | 37     | 50     | 26     | 23     | 12       |
| 编码 | b      | H      | l      | y      | a      | X      | M        |

补充'='后可得：`bHlyaXM=`。

这就是`lyris`的Base64编码啦。整个逻辑这个逻辑简单又直接，可以说大家都可以很轻松的写出一个自己的Base64编解码器。

##### 为什么要用Base64

从上面的编码原理我们可以看出：

- Base64没有加密功能，任何人都可以轻松的编解码。

- Base64编码后数据不减反增，将6bit变为一个长度为8bit的字符，数据量增加了1/3。

看起来好像挺垃的，那Base64有什么用呢？

1. 避免网络传输中的错误

首先，我们从<u>Base64编码所做的事情</u>来看：它可以把任何二进制数据变成由<u>64种最基本的字符</u>组成的数据。除了这64种基本的字符之外，我们知道还有很多各种各样的字符，包括空格、等号、中文汉字等等。但是，并不是所有编码方式或传输协议都支持这些字符。因此，数据的传输需要**兼容**的策略，而把它们都转换成简单易懂的Base64字符串就是一种方法。

我们熟悉的标准ASCII码为7位，仅支持编码128种字符，其中包括英文字母和多种符号，以及一些控制字符。控制字符属于"不可见字符"，它们的含义包括分隔符、删除、开始、结束等等。这些字符是无法转为我们可见的字符串的，显然它们不适合直接地进行传输和写入。

并且，ASCII有限的位数的无法编解码很多其他语言包括中文在内的大量字符，因此更多时候需要使用能力范围更大的编码方式来编入更多字符，例如Unicode。而Unicode的一个字符一般是2个字节以上，例如UTF-8，最大的字符会占6个字节。

在数据被传输和处理的过程中，我们不能保证大家都是以相同的方式处理字符的，不同编码方式编码出的数据在传输时就有被处理错误的可能性。尤其在传输一些图片、音频、视频时，其数据中可能包含很多不可见字符。如果有部分符号在一些特定的场景中还具有特殊的含义可能会产生歧义。那么如果我们将数据编码为Base64，一切数据都由这64种最简单的字符来表示，那么大家就都看得懂、都能支持，且没有歧义、不容易出错了。

另外，网络传输协议中有很多基于文本的协议，例如最简单的SMTP协议。当我们传输的邮件中包含图片或音频这种二进制数据，就可以将它们转换成Base64文本。在网页上，我们也可以把一些不大的图片资源用Base64的方式静态的打包到页面上，简化资源的请求传输过程。

2. 隐藏信息

其次，我们可以<u>从Base64编码的表现效果</u>来看：它可以把一串有意义的字符或数据转变成<u>无意义的字符串</u>。虽然解码并不困难，但是它至少可以使得数据**不能直接可见**。

这在日常生活中可能有一些应用空间。如果你想把一些个人的信息或联系方式（例如邮箱等）分享到互联网上，但又担心有人通过爬虫等方式通过关键字恶意收集这些信息给你带来骚扰或损失（我也不知道现在还有没有这种事），就可以把这些信息用Base64编码一下，真正需要的使用者也可以轻松地解码得到信息...



### JPEG图像数据

说到图片数据，不禁让人好奇，一个图片到底包含哪些数据？不同格式的图片它们的数据存储格式有什么不同呢？既然想到这里，我们就来简单地了解一下最常见的JPEG图片。

##### 颜色模式

位图，即bitmap，是由一个一个的像素组成的。每一个像素都有它的颜色。把位图放的很大，你就会看到一个一个的像素点：

![enter image description here](image/pix.png)

![enter image description here](image/svggg.png)

（矢量图放的再大都不会，固定的形状和线条依旧分明。）

位图中，一个像素的颜色由红(R)，绿(G)，蓝(B)三种"基色"构成，也就是所谓的RGB color model，它是一种用于在电子系统中显示图像的标准，用红、绿、蓝三种颜色的不同强度以数值的方式来定义任何一个颜色。这三种颜色被称为"颜色通道"。

其实在我们的电子屏幕上的每个像素也都是由三个聚集在一起的RGB光源组成的，因为它们足够小并且靠的很近，所以在我们肉眼看来就是合成后的一个特定颜色。在用数值来表示一个颜色的时候，我们就用分别用1byte的空间来表示R、G、B三色的强度，也就是一个0~255之间的整数。另外也许你也有见过"ARGB"或是"RGBA"这样的说法，其中的A指的是"Alpha Channel"，即阿尔法通道，它指的是一张图片的透明/半透明度。

还有一种颜色编码方式方式叫做CMYK。CMYK也叫"印刷四分色模式"，使用青、品红、黄、黑四种颜色的含量来表示一种颜色。我们知道RGB模式用于屏幕显示，所以它遵循的是"三原色光模式原理"，也就是说它的颜色合成原理是来自于光的颜色合成。但是CMYK遵循的是"色料的三原色原理"，它的合成原理类似于颜料的合成，通常在油墨印刷中使用。

![enter image description here](image/Colour_codes.jpg)

但是事实上JPEG支持的颜色模式是另一种，叫做YUV颜色模式，也叫做YCbCr颜色模式。它对每个像素都用亮度分量(Y)，蓝色色度分量(Cb)和红色色度分量(Cr)来表示。当我们使用JPEG标准对图片进行压缩的时候，图像的颜色模式会被转换为YCbCr模式。

![enter image description here](image/YCbCr-color-spaces.jpg)

了解颜色的表示方式之后，现在来讨论一下图片的数据大小。我们知道一个像素点需要三个字节的空间来表示其颜色，那么，假设我们有一张200*200大小的彩色表情包（这样的图片并不大，放大一些就能看到一个一个的像素格子）如果用这种方式来计算的话，它就需要占用：

```
200 * 200 * 3 / 1025 ≈ 117.2 KB
```

117.2KB的存储空间。但是实际上在我们的生活中，一张这样的200*200的图片实际上占用的空间一般都没有这么大，比方说这张图片：

![enter image description here](image/图.png)

显然，这张200*200的图片仅占据16.5KB左右的空间。这就是因为图像压缩的存在。不同格式的图片在图像压缩上有着不同的策略，从而导致它们存储的数据以及占用的存储空间都不同。不过，这篇文章并没有要探究图像压缩算法的意思，我们仅从JPEG图片的数据格式入手了解。

##### JPEG数据格式

我们通常把JPEG理解成一种文件格式，但是它实际上是一种"标准"。JPEG是"联合图像专家小组Joint Photographic Experts Group"的简称，听起来是一个组织，但是它通常代表的是这个组织所制定的一种图像压缩标准。JPEG的压缩是在尽量不去影响图片被人眼识别的效果的前提下，将图片压得尽量更小。但是它是一种有损压缩，因此当压缩率大到一定程度时，图片的可识别的质量总会有所降低。

一般来说，JPEG标准图像的文件格式是"JFIF"，即JPEG File Interchange Format（JPEG文件交换格式），或"EXIF"，即Exchangeable Image File（可交换图片文件）。这里说的格式指的就是图片数据的存储格式了。这些格式均遵循JPEG标准中定义的JIF（JPEG Interchange Format）文件格式标准，但在其上增加了一些"Marker（标记）"。使它更容易实现。

那么"标记"是什么呢？首先要知道，JPEG的数据是由一个个被标记的段落，或者说分区组成的。

在一个分区的开头会有一个2个字节长的标识符，其中第一个字节总是`ff`，后一个字节各不相同，这就是"标记"。然后会用两个字节记录这一分段存储数据的长度。最后记录了图片的一些特定的具体数据。唯二的两个例外是表示数据开始的SOI和表示数据结束的EOI。这个两个Marker单独存在，没有后续的内容。 其他的段落结构如下图：

![enter image description here](image/段.png)

至于具体有哪些标记段，JFIF和EXIF这两种格式也有一些区别，但是由于遵循JIF格式标准，也有很多是相同或相似的。主要的Marker包括以下这些：

| Marker名称 | Marker内容        | 说明                                                         |
| :--------- | :---------------- | :----------------------------------------------------------- |
| SOI        | 0xFF D8           | Start Of Image 图片开头                                      |
| SOF0       | 0xFF C0           | Start Of Frame 0 第0帧开始，若有后续帧以此类推               |
| DHT        | 0xFF C4           | Define Huffman Table(s) 霍夫曼表，用于编解码                 |
| DQT        | 0xFF DB           | Define Quantization Table(s) 量化表，用于编解码              |
| DRI        | 0xFF DD           | Define Restart Interval 差分编码累计复位的间隔，用于出错后重新同步或多线程编解码。 |
| SOS        | 0xFF DA           | Start of Scan 扫描线开始，后跟图像压缩数据                   |
| RST0~RST7  | 0xFF D0 ~ 0xFF D7 | Restart 重启标记，DRI表示的就是RST之间的间隔                 |
| APP0~APP15 | 0xFF E0 ~ 0xFF EF | Application-sepcific 应用程序保留标记，除了APP0记录版本号、像素密度、缩略图信息等等之外，其他的APPn应用可以根据需要保存不同的信息，对图片本身没有影响 |
| EOI        | 0xFF D9           | End of Image 图片结束                                        |

现在我们来把刚才那个200*200的图片用`hexdump`命令读取出来看一看。数据很长，仅截取开头的一小段（行首的那一段是便于查找的行号，忽略）：

![enter image description here](image/例子.jpg)

开头的这一小段我们看到了很多Marker，也可以看出Marker后的2个字节准确的表示了段落的长度。细心的你可能会发现，SOS标记后显示长度为`00 0c`，即12字节，但是12字节后并没有下一个Marker。这是因为SOS标记后的长度仅表示SOS数据头的长度，其后的压缩数据的长度是不包含在内的。

上面我们说过，JPEG图片的开头总会有SOI标记来标识数据的开始，并且它没有后续的长度表示和内容，因此后续还会紧跟一个`ff`。这说明JPEG图片的数据开头总会是`ffd8ff`。还记得我们说过的Base64编码方法吗？如果将`ffd8ff`，即`1111 1111 1101 1000 1111 1111`编码成Base64：

| 分组 | 111111 | 111101 | 100011 | 111111 |
| ---- | ------ | ------ | ------ | ------ |
| 索引 | 63     | 61     | 35     | 63     |
| 编码 | /      | 9      | j      | /      |

是的，JPEG图片转成Base64之后开头一定是`/9j/`，下次如果看到这样的Base64数据，就知道它是一张JPEG图片了（虽然好像没什么用）。



