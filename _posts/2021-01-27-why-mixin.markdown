---
layout: post
title: Dart学习心得 - 为什么要使用mixin？
image: 9.jpg
date: 2021-01-27 16:36:20 +0200
tags: [Flutter]
categories: Flutter
---

## Mixin是什么

mixin机制为我们提供了一种组织行为、复用代码的方式，可以使我们的代码结构更加清晰、简单和直观。先来看看它的具体定义用法：

- mixin是一种特殊的类，它包含的方法和变量可以供其他类使用，但是不需要成为其他类的父类。

- 其他的类可以通过`with`关键词来将一个mixin与自己”混合“以使用mixin的方法和变量，但它们之间不存在继承的关系。

- 想要让一个类作为mixin被使用，则它不能声明构造方法，也不能继承Object以外的其他的父类。如果它仅仅作为mixin被使用，则用mixin关键词代替class。
- 可以用`on`关键词来限定使用这个mixin的类必须是某个类或它的子类。

```dart
mixin Fly on Bird {
  // 只有Bird子类可以使用这个Fly mixin
  ...
}

mixin Walk on Bird{
  ...
}

class Parrot extends Bird with Fly, Walk implements Flyable {
  // 先extends，再with，最后implement。
  ...
  // Fly、Walk就是两个mixin
  // 现在这个Parrot类拥有了Fly、Walk中定义的属性和方法。
  // 默认使用mixin中的方法实现，但也可以在这里override这些方法。
}
```

它其实十分的直白：把需要被复用的一些代码整理成一个mixin，然后哪里需要就在哪里混入就行。

## 为什么我们需要mixin

这么一看，你可能会觉得mixin的实际使用和继承父类、实现接口很像（在Dart中虽然没有接口Interface，但是它的每一个类都可以被看成一个接口）。那我们为什么还需要mixin呢？

先说<u>结论</u>：确实，mixin并没有为我们提供什么崭新的**能力**，而是提出了一种新的**逻辑**：复用代码，却没有继承关系。在没有mixin的世界里，我们总是使用继承、接口、组合，但有时候，它们带来的依赖关系是多余的，反而会使系统变得复杂、难以理解。而mixin就是为了这些场景而存在的。

### 与实现接口相比

mixin的主要作用是为了复用代码，这一点和继承类似。但是刚才说过，一个类是用`with`关键词来混入一个mixin的。从英文的角度去看，"with"代表"伴随、与"，mixin的使用则可以理解成"[类]伴随了[mixin]"或是"[类]连同[mixin]一起"。这更像是一种"融合"，和继承所使用的"extends"（扩展）相去甚远。我倾向于把一个mixin理解成一个"能力"，或者说，一个封装好的小"技能包"，我们的类可以去习得这些技能，将自己与其融合，从而拥有这些能力。从逻辑上来说，这个思路和interface是相似的，而区别就在于interface只提供接口作为一种规范，而mixin提供具体实现以达到代码复用的目的。

### 与继承父类相比

本质上来看，mixin和继承一样是为了复用代码，但是Dart只支持单继承，却可以混入多个mixin。

这样一来你可能又会想到，其实mixin所做的事情，多继承似乎也都可以做到。那mixin的存在，是不是只是为了解决语言只支持单继承的问题呢？为什么我们不能直接设计一种多继承的解决办法来代替mixin呢？

如果去深究其内部原理，或许mixin不会有什么优于继承的地方，复用代码的效果也是相似的，所以这两种方案理论上可以互为替代。但是从抽象的角度去看，mixin"不产生继承关系"的特性会使得代码复用变得更简单直接，可以解决一些多继承或者继承关系本身带来的麻烦和存在的问题。

#### 多继承的问题

首先，多继承机制是存在一些问题的，其中首当其冲的就是菱形继承问题（钻石问题）带来的二义性（即当子类的两个父类都继承自一个相同的基类时，两个父类各持有一套基类的实例数据，子类不知道该使用哪一套）。

C++使用了虚继承来解决这个问题，让子类代替两个父类来执行基类的初始化。或许它能很好地解决一部分场景中的问题，但是多继承产生的网状关系依然很容易带来很多不必要的混乱，因此实际上在有其他可选方案的情况下很少会选择多继承。

那可能你会想问，mixin不会产生二义性吗？如果同一个类使用的两个mixin中有同名方法怎么办呢？如果`on`声明的基类中也有同名方法会怎样呢？事实上，使用时的实际情况是这样的：后一个声明的mixin中的方法会覆盖掉前一个mixin中或是基类中的同名方法。直接的调用都会使用后声明的mixin中的实现。

这是因为，基类与mixin之间，以及同时声明的mixin之间，并不是类似多继承的并列关系，而是形成了一种有顺序的线性关系。这个线性关系可以看做是单继承的一条链，假设两个mixin都`on`了同一个基类，它们内部的层次可以表示为：【基类-> 先声明的mixin -> 后声明的mixin】。例如在最开始的例子中，如果基类`Bird`、mixin `Fly`和`Walk`中都实现了一个方法`flying()`，那么下层的实现可以看做是对上层实现的override。我们可以也可以在下层用`super`来调用上层的实现。

关于这个问题的细节可以看这篇文章：[彻底理解 Dart mixin 机制](https://juejin.cn/post/6844903858209062920)，里面有比较详细的示例。另外他还举出了在binding.dart中的`WidgetsFlutterBinding`类使用mixin的例子，它用mixin的顺序保证了操作执行的顺序。这也是mixin具有的一种方便的能力。

#### 继承关系的问题

退一步讲，即使不考虑多继承本身存在的问题，继承本身也有不足的地方和满足需求的时候。我们知道继承的目的就是复用代码，使原有的类符合OCP。但是是否只要是需要复用代码的情景，就可以使用继承呢？在我看来并不是的，在很多情境下，我们可能并不希望继承关系的存在。

##### 系统混乱

现在也有一些说法在倡导减少对继承的使用，以避免系统过度复杂和混乱。当我们的系统中有很多的"能力"需要在多个类层次结构中被使用时，通过"成为这种能力拥有者的子类"的方式来复用这种能力可能就不是最好的解决方法了，因为这样会产生复杂的依赖关系。

使用类的组合是一种解决方式，但是组合需要我们创建实例对象，还要封装访问对象的接口，在需要大量复用的情况下就比较麻烦了。所以，把这些能力用mixin来整理和复用或许是一个更好的选择，因为混入mixin可以轻松的实现对能力的”借用“，并且不会使类之间产生逻辑上的关联。

另外，我们还可以单纯的利用mixin对过长过大的类做拆分，增强代码的可读性，且不会产生其他影响。

##### 逻辑上的”is-a“关系

继承本质是在定义一种"is-a"的关系，"[子类] is a [父类]"。例如“Student is a Person”、“Cat is an Animal”。多态的特性也可以证明这一点：多态的其中一个要求就是我们可以用父类的引用去指向子类的对象，这暗示我们用父类去描述一个子类必须是合理的。因此我们需要在使用继承之前准确的判断两个类在逻辑上是否足够贴近这种"is-a"的关系。如果我们想要复用的代码更类似于一种通用的”能力“，那显然使用mixin在逻辑上更为通顺。

正如上文所说的，mixin更像一种封装起来的"技能包"，我们的类想拥有这种技能，但是自己并想成为一个"技能包"，而只想做一个"使用者"。这就是选择mixin的原因之一。

---

最后再说一遍结论：mixin并没有提供新的能力，因为继承、接口、组合的使用可以达到同样的最终效果。但是，它提供了"复用代码，却没有继承关系"的这种新的逻辑，在包含上述情况在内的很多时候，可以避免继承、接口、组合所带来的的不必要的麻烦，也可以使我们项目中代码的整体结构更加清晰简单，易于理解。

